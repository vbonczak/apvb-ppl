
open Array

type 'a support = { values : 'a array;
                    logits : float array;
                    probs : float array;
                  }

type 'a dist = { support : 'a support option;
                 sample : unit -> 'a;
                 logpdf : 'a -> float;
                 exp : (unit -> float) option;
                 var : (unit -> float) option;
               }

let bernoulli p =
  assert(0. <= p && p <= 1.);
  let values = [|0; 1|] in
  let probs = [|1. -. p; p|] in
  let support = {values = values;
                 logits = Array.map log probs;
                 probs = probs}
  in
  let sample () = if Random.float 1. <= p then 1 else 0 in
  let logpdf x = assert(x = 0 || x = 1); support.logits.(x) in
  let exp () = p in
  let var () = p *. (1. -. p) in
  let d = {support = Some support;
           sample = sample;
           logpdf = logpdf;
           exp = Some exp;
           var = Some var;
          } in
  d
;;

let rec pow_int a n = match n with
  |0 -> 1
  |_ -> a * (pow_int a (n-1))
;;

let rec pow_float a n = match n with
  |0 -> 1.
  |_ -> a *. (pow_float a (n-1))
;;

let binomial p n =
  assert(0. <= p && p <= 1. && n >= 0);
  let values = Array.init (pow_int 2 n)
                 (fun i -> Array.init n (fun j -> i mod (pow_int 2 j)))
  in
  (* Each element is an array containing a sequence of ones and zeroes, each element is the binary representation of the current index. *)
  let probs = Array.init (pow_int 2 n)
                (fun i ->
                  let k = Array.fold_left (+) 0 (values.(i)) in
                  (pow_float p k) *. (pow_float (1. -. p) (n-k)))
  in
  let support = {values = values;
                 logits = Array.map log probs;
                 probs = probs;
                } in
  let sample () = Array.init n
                    (fun _ -> if Random.float 1. <= p then 1 else 0)
  in
  let logpdf x = assert(length x = n);
                 Array.iter (fun y -> assert(y = 0 || y = 1)) x;
                 let k = Array.fold_left (+) 0 x in
                 log ((pow_float p k) *. (pow_float (1. -. p) (n-k)))
  in
  let exp () = float_of_int n *. p in
  let var () = float_of_int n *. p *. (1. -. p) in
  let d = {support = Some support;
           sample = sample;
           logpdf = logpdf;
           exp = Some exp;
           var = Some var;
          } in
  d
;;

let uniform a b =
  assert(a < b);
  let sample () = a +. Random.float (b-.a) in
  let logpdf x = if (a <= x && x <= b) then 1. /. (b -. a) else 0. in
  let exp () = (a +. b) /. 2. in
  let var () = (pow_float (b -. a) 2) /. 12. in
  let d = {support = None;
           sample = sample;
           logpdf = logpdf;
           exp = Some exp;
           var = Some var;
          } in
  d
;;

let rec remove x q = match q with (* This function returns q with occurences of x removed and the number of such values removed. *)
  |[] -> [], 0.
  |y::q when y=x -> let l, occs = remove x q in l, occs +. 1.
  |y::q -> let l, occs = remove x q in y::l, occs
;;

let rec regroup l n = match l with (* Returns two lists l1 and l2, l1 gives the elements of l without repetition and l2 gives the corresponding proportion of occurences of each element in l. *)
  |[] -> [],[]
  |x:: _ ->
    begin
      let l', occs = remove x l in
      let values, occurences = regroup l' n in
      x::values, (occs /. n)::occurences
    end
;;

module Rejection_sampling = struct

exception Reject;;

let assume bool = if not bool then raise Reject else ();;

let observe d x = assume (d.sample() = x);;

let infer n f = (* Version for finite support and rejection sampling. *)
  assert(n > 0);
  let rec aux n = match n with
  |0 -> []
  |n -> try let x=f() in x::(aux (n-1)) with Reject -> aux n
  in
  let vals, proportions = regroup (aux n) (float_of_int n) in
  let values = Array.of_list vals in
  let probs = Array.of_list proportions in
  let support = {values = values;
                 logits = Array.map log probs;
                 probs = probs}
  in
  
  let sample () =
    let p = Random.float 1. in (* Assume we split the interval [0,1] into length(prob) intervals, with interval i having length prob.(i). We then generate a random float between 0 and 1 and see which interval it falls in to generate a random value according to prob. *)
    let i = ref 0 in
    let x = ref 0. in
    while p > !x +. support.probs.(!i) do x := !x +. support.probs.(!i); incr i; done;
    support.values.(!i)
  in
  let logpdf x =
    let index, bool = Array.fold_left
                        (fun (i,b) y -> if b || y = x then (i,true) else (i+1,b))
                        (0,false)
                        values
    in
    assert(bool);
    support.logits.(index) in
  (*let exp = try Some( fun () ->
      let m = ref 0. in
      for i=0 to Array.length values-1 do
        m := !m +. values.(i) *. probs.(i)
      done;
      !m)
      with _ -> None in*)
  let d = {support = Some support;
           sample = sample;
           logpdf = logpdf;
           exp = None;
           var = None;
          } in
  d
;;

let sample d = d.sample();;

end

exception DifferentSize

let rec remove_with_score x q scores = match q, scores with (* This function returns q with occurences of x removed, scores with scores corresponding to x removed, and the total score of elements x in q. *)
  |[], [] -> [], [], 0.
  |[], _ |_, [] -> raise DifferentSize
  |y::q, score::s when y=x -> let l1, l2, total_score = remove_with_score x q s in l1, l2, score +. total_score
  |y::q, score::s -> let l1, l2, total_score = remove_with_score x q s in y::l1, score::l2, total_score
;;

let rec regroup_with_score (values, exp_scores) = match values with (* Returns two lists l1 and l2, l1 gives the elements of values without repetition and l2 gives the total score of each element in l. The scores are now assumed to be no longer in logarithmic form since we need to compute the sum. *)
  |[] -> [],[]
  |x:: _ ->
    begin
      let l1, l2, total_score = remove_with_score x values exp_scores in
      let values, scores = regroup_with_score (l1, l2) in
      x::values, total_score::scores
    end
;;
  
module Importance_sampling = struct

  exception ZeroScore
  
  let sample d = d.sample();;

  let factor score s = score := !score +. s;;

  let observe score d x = score := !score +. (d.logpdf x);;

  let assume score bool = if not bool then score := neg_infinity;;

  let infer n model obs =
    assert(n > 0);
    let rec aux n = match n with
      |0 -> [],[]
      |n -> let score = ref 0. in
            let x = model score obs in
            let l1, l2 = aux (n-1) in
            x::l1, (exp !score)::l2 (* Once the calculations done with log probabilities, we return to regular probabilities to regroup scores for the same values. *) 
    in
    let vals, scores = regroup_with_score (aux n) in
    let rec sum_scores scores = match scores with
      |[] -> 0.
      |x::q -> x +. (sum_scores q)
    in
    let total_score = sum_scores scores in
    if total_score = 0. then raise ZeroScore;
    let values = Array.of_list vals in
    let probs = Array.of_list (List.map (fun x -> x /. total_score) scores) in
    let support = {values = values;
                   logits = Array.map log probs;
                   probs = probs}
    in
  
    let sample () =
      let p = Random.float 1. in (* Assume we split the interval [0,1] into length(prob) intervals, with interval i having length prob.(i). We then generate a random float between 0 and 1 and see which interval it falls in to generate a random value according to prob. *)
      let i = ref 0 in
      let x = ref 0. in
      while p > !x +. support.probs.(!i) do x := !x +. support.probs.(!i); incr i; done;
      support.values.(!i)
    in
    let logpdf x =
      let index, bool = Array.fold_left
                          (fun (i,b) y -> if b || y = x then (i,true) else (i+1,b))
                          (0,false)
                          values
      in
      assert(bool);
      support.logits.(index) in
    let d = {support = Some support;
             sample = sample;
             logpdf = logpdf;
             exp = None;
             var = None;
            } in
    d
  ;;
               
end
                               


module MH_Multi = struct

  let sample d = d.sample();;
  
  let infer n f score = (* score takes a sample as input, and returns a float as score *)
    let x = f() (* First sample *) in
    let w0 = score x in
    let rec aux n x w = match n with
      |0 -> x
      |n -> begin
          let y = f() in
          let wi = score y in
          let p = Random.float 1.
          if p *. w <= wi then aux (n-1) y wi else aux (n-1) x w;
        end
    in aux (n-1) x w0
  ;;

  end
                 
module MH_Single = struct (* Assume all samples return type float. *)

  type location = Decl of nat (* Which declaration in a sequence of instructions without for or if *)
                | If of bool * location
                | For of nat * location
  (* Describes where a variable is located in the code so as to distinguish different instructions of the form "let x = sample ..." *)
  
  type variable = string * location (* name and location *)

  type graph_of_vars = variable list * variable list list (* Vertices (variables) and edges (dependencies) *)

  let sample v variables d = (* v is the name of a variable*)
                     
  let infer n first_f resample_f score = (* first_f executes all samples in the function, resample_f resamples one variable and all its dependencies. They both return the value of the sample for each variable. *)
    let x, variables_and_samples = first_f() in (* variables_and_samples is of type (variable * float) list *)
    let w0 = score x in
let rec aux n 
  end


                 
